import numpy as np
from pathlib import Path
import sys
import os
sys.path.append(str(Path(os.path.abspath(__file__)).parent.parent))

def backward(state2state, state2observation, initial_state, observation):
    """
    Given a HMM with parameter (state2state, state2observation, initial_state)
    and the observation,
    return the probability of the observation generated by this HMM

    state2state is a matrix shaped of [state_size, state_size]
    state2observation is a matrix shaped of [state_size, observation_size]
    initial_state is a tensor shaped of [state_size], whose each dimension means the probability of each state
    observation is a tensor shaped of [sequence_length]
    observation_size is the number of all the possible observations

    the return value consists of two parts:
    the probability of the observation,
    and a sequence of probability of each state of each step
    """
    state_size, _ = state2state.shape
    sequence_length, = observation.shape

    seq_state_likelihood = np.zeros([sequence_length, state_size])
    state_likelihood = np.ones_like(initial_state)
    for i in range(sequence_length - 1, -1, -1):
        o = observation[i]
        # given the parameter of HMM and each possible state this step, get the probability of the following observation
        state_likelihood = state2state @ state_likelihood
        seq_state_likelihood[i] = state_likelihood
        # given the observation of this step, get the probability of this state
        state_likelihood *= state2observation[:, o]
    state_prob = state_likelihood * initial_state
    return sum(state_prob), seq_state_likelihood


if __name__ == '__main__':
    A = np.array(
        [[.5, .2, .3],
         [.3, .5, .2],
         [.2, .3, .5]]
        )
    B = np.array(
        [[.5, .5],
         [.4, .6],
         [.7, .3]]
        )
    pi = np.array([.2, .4, .4])
    observation = np.array([0, 1, 0])
    print(backward(A, B, pi, observation)[0])
